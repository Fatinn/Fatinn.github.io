<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="LeetCode221周赛"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>LeetCode220周赛 | Fatinn</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a></nav><div class="container post-meta"><div class="post-time">2021-08-10</div></div></div><div class="container post-header"><h1>LeetCode220周赛</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">目录</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5629-%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">5629.重新格式化电话号码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5630-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">5630.删除子数组的最大得分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5631-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI"><span class="toc-number">3.</span> <span class="toc-text">5631.跳跃游戏VI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5632-%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">4.</span> <span class="toc-text">5632.检查边长度限制的路径是否存在</span></a></li></ol></details></div><div class="container post-content"><p>LeetCode221周赛</p>
<h1 id="5629-重新格式化电话号码"><a href="#5629-重新格式化电话号码" class="headerlink" title="5629.重新格式化电话号码"></a>5629.重新格式化电话号码</h1><p>这题千万不要多想，就是模拟，该怎么做怎么做。</p>
<p>看代码就明白了，虽然打字有点多，但是一遍过的几率高，思路清晰。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reformatNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                t+=c;</span><br><span class="line">        <span class="keyword">int</span> len=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">3</span>) <span class="keyword">return</span> t;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len<span class="number">-4</span>;i+=<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=t[i];</span><br><span class="line">            res+=t[i+<span class="number">1</span>];</span><br><span class="line">            res+=t[i+<span class="number">2</span>];</span><br><span class="line">            res+=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len-i==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=t[len<span class="number">-4</span>];</span><br><span class="line">            res+=t[len<span class="number">-3</span>];</span><br><span class="line">            res+=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            res+=t[len<span class="number">-2</span>];</span><br><span class="line">            res+=t[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len-i==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=t[len<span class="number">-3</span>];</span><br><span class="line">            res+=t[len<span class="number">-2</span>];</span><br><span class="line">            res+=t[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len-i==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=t[len<span class="number">-2</span>];</span><br><span class="line">            res+=t[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="5630-删除子数组的最大得分"><a href="#5630-删除子数组的最大得分" class="headerlink" title="5630.删除子数组的最大得分"></a>5630.删除子数组的最大得分</h1><p><code>前缀和+滑动窗口</code> 利用set来查重。</p>
<p>求出前缀和之后，利用滑动窗口，当子数组中出现相同元素时，左侧收缩，直到没有相同元素，然后找到最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumUniqueSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pre</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            pre+=pre[i<span class="number">-1</span>];</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(nums[r])!=set.<span class="built_in">end</span>())</span><br><span class="line">                set.<span class="built_in">insert</span>(nums[r]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(nums[l]!=nums[r])</span><br><span class="line">                &#123;</span><br><span class="line">                    set.<span class="built_in">erase</span>(nums[l++]);</span><br><span class="line">                &#125;<span class="comment">// 当有了相同元素后，那么说明这个子数组就不能用了，所以左侧就要收缩，找到下一个没有重复元素的区间，那么在相同元素的左侧的数值也就不需要了，直接erase掉，而循环退出的条件便是左侧等于右侧的时候</span></span><br><span class="line">                l++; <span class="comment">//窗口左侧要跳过相同的</span></span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">max</span>(res,l &gt; <span class="number">0</span> ? pre[r]-pre[l<span class="number">-1</span>] : pre[r]);<span class="comment">//之所以是l-1是因为求区间和，所以前缀和要减掉前面那个。而如果l=0就是整个数组的话，那么就直接是pre[r]了。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5631-跳跃游戏VI"><a href="#5631-跳跃游戏VI" class="headerlink" title="5631.跳跃游戏VI"></a>5631.跳跃游戏VI</h1><p><code>动态规划+单调队列</code></p>
<p>如果直接进行DP的遍历求解，那么时间复杂度是n的平方，而给的数据范围是10的5次方，所以必然超时。</p>
<p>那么我们来看题，对于DP[i]的值，它只能取自范围 i-k到i-1，那么我们只需要维护一个数值严格递减的队列，每次从队首取出元素，那么DP[i]就等于q.front() + nums[i].</p>
<p>维护队列时注意两点，一是数值严格递减，二是大小局限在i-k之内。</p>
<p>而队列中，我们只需要存放数组位置即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxResult</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">front</span>()&lt;i-k) q.<span class="built_in">pop_front</span>(); <span class="comment">//维护范围</span></span><br><span class="line">            dp[i]=dp[q.<span class="built_in">front</span>()]+nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; dp[q.<span class="built_in">back</span>()]&lt;=dp[i])</span><br><span class="line">                q.<span class="built_in">pop_back</span>(); <span class="comment">//维护严格递减</span></span><br><span class="line">            q.<span class="built_in">push_back</span>(i);  <span class="comment">//将位置放入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5632-检查边长度限制的路径是否存在"><a href="#5632-检查边长度限制的路径是否存在" class="headerlink" title="5632.检查边长度限制的路径是否存在"></a>5632.检查边长度限制的路径是否存在</h1><p>``离线算法+并查集`</p>
<p>离线算法就是题目会给定所有的条件和要求，你可以对于全部的信息进行自己所需要的干的事情。</p>
<p>本题中，如果要对query中每条边都进行查询，那么10的5次方的量级必然会超时。但是如果转变成里显得思想，因为每个query是要判断从pi到qi所有边上小于limit(i)的路径，如果limit(i)是从小到大排列的，我们就可以顺次在图上，每次把小于limit(i)的边添加上，然后用并查集查看当前的query关心的pi到qi是否连通。</p>
<p>这样做的核心在于，我们一边处理 query，一边处理边，不是一次性的把所有的边都考虑进来，而是根据 query 的 limit 从小到大的限制，从小到大依次考虑边。</p>
<p>注意，这个思路需要我们首先对整个 query 数组排序，之后再处理，所以需要收集到所有 query 信息以后再执行，所以它是一个离线算法。</p>
<p>那么思路就是这样，代码也就基本上是把思路翻译出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	vector&lt;<span class="keyword">int</span>&gt;parent;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">UF</span>(<span class="keyword">int</span> n) : <span class="built_in">parent</span>(n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=parent[p])</span><br><span class="line">            parent[p]=<span class="built_in">find</span>(parent[p]);</span><br><span class="line">        <span class="keyword">return</span> parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot=<span class="built_in">find</span>(p), qRoot=<span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">        parent[pRoot] =qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">distanceLimitedPathsExist</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edgeList, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(edgeList.<span class="built_in">begin</span>(),edgeList.<span class="built_in">end</span>(),[](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; e1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; e2)&#123;</span><br><span class="line">            <span class="keyword">return</span> e1[<span class="number">2</span>]&lt;e2[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            queries[i].<span class="built_in">push_back</span>(i); <span class="comment">//因为要对queries排序，所以要先储存好原来的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(queries.<span class="built_in">begin</span>(),queries.<span class="built_in">end</span>(),[](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;q1,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp; q2)&#123;</span><br><span class="line">            <span class="keyword">return</span> q1[<span class="number">2</span>]&lt;q2[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">res</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ep=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ep &lt; edgeList.<span class="built_in">size</span>() &amp;&amp; edgeList[ep][<span class="number">2</span>]&lt;querise[i][<span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                uf.<span class="built_in">unionElements</span>(edgeList[ep][<span class="number">0</span>],edgeList[ep][<span class="number">1</span>]);</span><br><span class="line">                ep++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res[queries[i][<span class="number">3</span>]] = uf.<span class="built_in">isConnected</span>(queries[i][<span class="number">0</span>],queries[i][<span class="number">1</span>]);  <span class="comment">//注意是[i][3]因为是原来的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>