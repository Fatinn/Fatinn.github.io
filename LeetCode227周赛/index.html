<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="LeetCode227周赛"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>LeetCode227周赛 | Fatinn</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 5.4.0"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-time">2021-08-10</div></div></div><div class="container post-header"><h1>LeetCode227周赛</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1752-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%BB%8F%E6%8E%92%E5%BA%8F%E5%92%8C%E8%BD%AE%E8%BD%AC%E5%BE%97%E5%88%B0"><span class="toc-number">1.</span> <span class="toc-text">1752.检查数组是否经排序和轮转得到</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1753-%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">1753.移除石子的最大得分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1754-%E6%9E%84%E9%80%A0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">1754.构造字典序最大的合并字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1755-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">1755.最接近目标值的子序列和</span></a></li></ol></details></div><div class="container post-content"><p>LeetCode227周赛</p>
<h1 id="1752-检查数组是否经排序和轮转得到"><a href="#1752-检查数组是否经排序和轮转得到" class="headerlink" title="1752.检查数组是否经排序和轮转得到"></a>1752.检查数组是否经排序和轮转得到</h1><p>数组原来是非递减的，所以即使轮换后，他们的逆序对也最大为1，所以可以遍历数组，统计逆序对数，最后和1比较返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[(i+<span class="number">1</span>)%n])</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="1753-移除石子的最大得分"><a href="#1753-移除石子的最大得分" class="headerlink" title="1753.移除石子的最大得分"></a>1753.移除石子的最大得分</h1><p>每次选个数最多的两堆，最后两堆为0结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt;t&#123;a,b,c&#125;;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">1</span>]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            t[<span class="number">2</span>]--;</span><br><span class="line">            t[<span class="number">1</span>]--;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="1754-构造字典序最大的合并字符串"><a href="#1754-构造字典序最大的合并字符串" class="headerlink" title="1754.构造字典序最大的合并字符串"></a>1754.构造字典序最大的合并字符串</h1><p><code>贪心</code></p>
<p>每次选取<strong>剩下</strong>字符串字典序最大的，然后将该字母放到新字符串最后。用C++自带的substr来选取剩余字符串。</p>
<p>如果哪个字符串有剩余，直接把他们全部放过去就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestMerge</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n1=word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2=word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n1 &amp;&amp; j&lt;n2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.<span class="built_in">substr</span>(i) &gt; word1.<span class="built_in">substr</span>(j))&#123;</span><br><span class="line">                res+=word1[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res+=word2[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n1)</span><br><span class="line">            res+=word1[i++];</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n2)</span><br><span class="line">            res+=word2[j++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="1755-最接近目标值的子序列和"><a href="#1755-最接近目标值的子序列和" class="headerlink" title="1755.最接近目标值的子序列和"></a>1755.最接近目标值的子序列和</h1><p>将原数组平分为左右两个数组，并分别计算这两个数组所有子序列和。</p>
<p>那么结果只有下面三种情况：</p>
<p>第一，结果出现在left数组中</p>
<p>第二，结果出现在right数组中</p>
<p>第三，结果出现在right和left数组中某两个的和。</p>
<p>那么第一和第二种情况直接遍历，更新找到最小的。</p>
<p>而对于第三种情况，问题退化成在两个数组中，分别找到一个数，使两者的和最接近目标值，那么对上述和进行排序，一个从小到大，一个从大到小，然后更新答案。</p>
<p>至于为什么一个从大到小，一个从小到大找可以找到正确答案。可以这么简单的理解：如果和大于goal，那么就必须让right数组的值减小，如果和小于goal，那么就让left数组的值增大，如果相同那么就直接返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//求所有子序列和，通过状态压缩方式存储</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">build</span>(vector&lt;<span class="keyword">int</span>&gt;nums)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">ans</span>(<span class="number">1</span>&lt;&lt;num.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;i);j++)</span><br><span class="line">                ans[j+(<span class="number">1</span>&lt;&lt;i)]=ans[j]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;left = <span class="built_in">build</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+n/<span class="number">2</span>);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;right= <span class="built_in">build</span>(nums.<span class="built_in">begin</span>()+n/<span class="number">2</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(left.<span class="built_in">begin</span>(),left.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(right.<span class="built_in">rbegin</span>(),right.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> ans=INT_MAX,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t : left)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(goal-t));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t : right)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(goal-t));</span><br><span class="line">        <span class="keyword">while</span>(i&lt;left.<span class="built_in">size</span>() &amp;&amp; j&lt;right.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> t=left[i]+right[j];</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(goal-t));</span><br><span class="line">            <span class="keyword">if</span>(t&gt;goal) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t&lt;goal) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>